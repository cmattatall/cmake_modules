cmake_minimum_required(VERSION 3.21)


function(GitMetadata_get OUT_git_rev OUT_git_diff OUT_git_tag OUT_git_branch)
    find_program(GIT_EXECUTABLE NAMES git REQUIRED) 
    execute_process(
        COMMAND ${GIT_EXECUTABLE} log --pretty=format:'%h' -n 1
        OUTPUT_VARIABLE GIT_REV
        ERROR_QUIET
    )

    # Check whether we got any revision (which isn't
    # always the case, e.g. when someone has downloaded a zip 
    # (looking at you ... windows users) file from Github 
    # instead of properly performing a checkout
    if ("${GIT_REV}" STREQUAL "")
        set(${OUT_git_rev} "GIT_REV-NOTFOUND" PARENT_SCOPE)
        set(${OUT_git_diff} "GIT_DIFF-NOTFOUND" PARENT_SCOPE)
        set(${OUT_git_tag} "GIT_TAG-NOTFOUND" PARENT_SCOPE)
        set(${OUT_git_branch} "GIT_BRANCH-NOTFOUND" PARENT_SCOPE)
    else()
        execute_process(
            COMMAND bash -c "git diff --quiet --exit-code || echo +"
            OUTPUT_VARIABLE GIT_DIFF)
        execute_process(
            COMMAND git describe --exact-match --tags
            OUTPUT_VARIABLE GIT_TAG ERROR_QUIET)
        execute_process(
            COMMAND git rev-parse --abbrev-ref HEAD
            OUTPUT_VARIABLE GIT_BRANCH)

        string(STRIP "${GIT_REV}" GIT_REV)
        string(SUBSTRING "${GIT_REV}" 1 7 GIT_REV)
        string(STRIP "${GIT_DIFF}" GIT_DIFF)
        string(STRIP "${GIT_TAG}" GIT_TAG)
        string(STRIP "${GIT_BRANCH}" GIT_BRANCH)

        set(${OUT_git_rev} "${GIT_REV}" PARENT_SCOPE)
        set(${OUT_git_diff} "${GIT_DIFF}" PARENT_SCOPE)
        set(${OUT_git_tag} "${GIT_TAG}" PARENT_SCOPE)
        set(${OUT_git_branch} "${GIT_BRANCH}" PARENT_SCOPE)
    endif()
endfunction(GitMetadata_get OUT_git_rev OUT_git_diff OUT_git_tag OUT_git_branch)


function(GitMetadata_write_header git_header)

    GitMetadata_get(GIT_REV GIT_DIFF GIT_TAG GIT_BRANCH)

    set(GIT_INFO_FILE_CONTENT "#ifndef __GIT_HEADER_H__\n#define __GIT_HEADER_H__\n\n/* Generated by cmake at configure-time from the git-repo state */\n#define GIT_REV \"${GIT_REV}${GIT_DIFF}\"\n#define GIT_TAG \"${GIT_TAG}\"\n#define GIT_BRANCH \"${GIT_BRANCH}\"\n\n#endif /* #ifndef __GIT_HEADER_H__ */")

    if(EXISTS ${git_header})
        file(READ ${git_header} EXISTING_GIT_INFO_FILE_CONTENT)
    else()
        set(EXISTING_GIT_INFO_FILE_CONTENT "")
    endif()

    if (NOT "${GIT_INFO_FILE_CONTENT}" STREQUAL "${EXISTING_GIT_INFO_FILE_CONTENT}")
        file(WRITE ${git_header} "${GIT_INFO_FILE_CONTENT}")
    endif()

endfunction(GitMetadata_write_header git_header)


function(GitMetadata_c_codegen c_filepath h_filepath)
    GitMetadata_get(GIT_REV GIT_DIFF GIT_TAG GIT_BRANCH)
    set(SYMBOL_PREFIX ${PROJECT_NAME})
    if(NOT SYMBOL_PREFIX)
        message(FATAL_ERROR "Error: ${CMAKE_CURRENT_LIST_FILE:${CMAKE_CURRENT_LIST_LINE} PROJECT_NAME not set. Cannot continue")
    endif(NOT SYMBOL_PREFIX)
    # We will use a symbol prefix based on the current project name
    # to prevent symbol collisions in large projects.
    string(TOUPPER ${SYMBOL_PREFIX} SYMBOL_PREFIX)
    string(REPLACE "-" "_" SYMBOL_PREFIX ${SYMBOL_PREFIX})
    string(REPLACE "\ " "_" SYMBOL_PREFIX ${SYMBOL_PREFIX})
    string(REPLACE "\t" "_" SYMBOL_PREFIX ${SYMBOL_PREFIX})
    string(REPLACE "\'" "" SYMBOL_PREFIX ${SYMBOL_PREFIX})
    string(REPLACE "\"" "" SYMBOL_PREFIX ${SYMBOL_PREFIX})
    string(REPLACE "\\" "" SYMBOL_PREFIX ${SYMBOL_PREFIX})
    string(REPLACE "\$" "" SYMBOL_PREFIX ${SYMBOL_PREFIX})
    set(C_FILE_CONTENT "char * ${SYMBOL_PREFIX}_GIT_META_get_rev() {\n\treturn \"${GIT_REV}\"\;\n}\n\nchar * ${SYMBOL_PREFIX}_GIT_META_get_tag() {\n\treturn \"${GIT_TAG}\"\;\n}\n\nchar * ${SYMBOL_PREFIX}_GIT_META_get_branch() {\n\treturn \"${GIT_BRANCH}\"\;\n}\n")
    set(H_FILE_CONTENT "#ifndef __GIT_METADATA_C__\n#define __GIT_METADATA_C__\n#ifdef __cplusplus\n/* clang-format off */\nextern \"C\"\n{\n/* clang-format on */\n#endif /* Start C linkage */\n\tchar * ${SYMBOL_PREFIX}_GIT_META_get_rev()\;\n\tchar * ${SYMBOL_PREFIX}_GIT_META_get_tag()\;\n\tchar * ${SYMBOL_PREFIX}_GIT_META_get_branch()\;\n#ifdef __cplusplus\n/* clang-format off */\n}\n/* clang-format on */\n#endif /* End C linkage */\n#endif /* __GIT_METADATA_C__ */\n")
    file(WRITE ${c_filepath} ${C_FILE_CONTENT})
    file(WRITE ${h_filepath} ${H_FILE_CONTENT})
endfunction(GitMetadata_c_codegen c_filepath h_filepath)


function(GitMetadata_target_add_metadata_sources TARGET)
    set(GIT_META_CODEGEN_C_FILE  ${CMAKE_CURRENT_BINARY_DIR}/codegen/git.c)
    set(GIT_META_CODEGEN_H_FILE  ${CMAKE_CURRENT_BINARY_DIR}/codegen/git.h)
    GitMetadata_c_codegen(${GIT_META_CODEGEN_C_FILE} ${GIT_META_CODEGEN_H_FILE})
    target_sources(${TARGET} PRIVATE ${GIT_META_CODEGEN_C_FILE})
    get_filename_component(GIT_META_CODEGEN_H_DIR ${GIT_META_CODEGEN_H_FILE} DIRECTORY)
    target_include_directories(${TARGET} PUBLIC $<BUILD_INTERFACE:${GIT_META_CODEGEN_H_DIR}>)
endfunction(GitMetadata_target_add_metadata_sources TARGET)
